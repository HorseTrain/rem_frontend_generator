O vector_shift<O>(O element, O shift, int bit_count, int is_unsigned)
{
    O result = 0;

    if (!is_unsigned)
    {
        element = extend o64 element;
    }

    if (shift cgte 0)
    {
        if (shift cgte bit_count)
        {
            set result 0;
        }
        else
        {
            set result element << shift;
        }
    }
    else
    {
        set shift -shift;

        if (shift cgte bit_count)
        {
            if (((element >> (bit_count - 1)) & 1) == 1 && !is_unsigned)
            {
                set result -1;
            }
            else
            {
                set result 0;
            }
        }
        else
        {
            if (!is_unsigned)
            {
                set result element sar shift;
            }
            else
            {
                set result element >> shift;
            }
        }
    }

    return result;
}

void convert_to_int(int sf, int ftype, int Rd, int Rn, int round, int is_unsigned, int to_vector)
{
    o64 operand = V(Rn);

    int intsize = 32 << sf;
    int fltsize = get_flt_size(ftype);

    o64 result = FPToFixed(operand, 0, is_unsigned, round, intsize, fltsize);

    if (to_vector)
    {
        V(Rd, result);
    }
    else
    {
        X(Rd, result);
    }
}

int lowest_bit_set_c(int source)
{
    int size = 32;

    loop (size) i
    {
        int working_bit = (source >> i) & 1;

        if (working_bit)
        {
            return i;
        }
    }

    return size;
}

void dup_element(int index, int esize, int elements, int n, int d)
{
    o128 operand = V(n);
    o128 result = vector_zero;

    o64 element = elm operand index esize;

    loop (elements) e
    {
        elm result e esize element;
    }

    V(d, result);
}

int get_flt_size(int ftype)
{
    if (ftype == 2)
    {
        return 64;
    }
    else
    {
        return 8 << (ftype ^ 2);
    }
}

int vfp_expand_imm(int imm8, int N)
{
    int E;

    if (N == 16)
    {
        E = 5;
    }
    else if (N == 32)
    {
        E = 8;
    }
    else
    {
        E = 11;
    }

    int F = (N - E) - 1;
    int sign = (imm8 >> 7) & 1;

    int exp = ~(bit_c(imm8, 6)) & 1;
    exp = (exp << (E - 3)) | replicate_c(bit_c(imm8, 6), 1, E - 3);
    exp = (exp << 2) | bits_c(imm8, 5, 4);

    int frac = bits_c(imm8, 3, 0) << (F - 4);

    int result = sign;

    result = (result << (1 + (E - 3) + 2)) | exp;
    result = (result << (4 + (F - 4))) | frac;

    return result;
}

int expand_imm(int op, int cmode, int imm8)
{
    int imm64 = 0;
    int cmode_test = bits_c(cmode, 3, 1);

    if (cmode_test == 0)
    {
        imm64 = replicate_c(imm8, 32, 2);
    }
    else if (cmode_test == 1)
    {
        imm64 = replicate_c(imm8 << 8, 32, 2);
    }
    else if (cmode_test == 2)
    {
        imm64 = replicate_c(imm8 << 16, 32, 2);
    }
    else if (cmode_test == 3)
    {
        imm64 = replicate_c(imm8 << 24, 32, 2);
    }
    else if (cmode_test == 4)
    {
        imm64 = replicate_c(imm8, 16, 4);
    }
    else if (cmode_test == 5)
    {
        imm64 = replicate_c(imm8 << 8, 16, 4);
    }
    else if (cmode_test == 6)
    {
        if ((cmode & 1) == 0)
        {
            imm64 = replicate_c((imm8 << 8) | ones(8), 32, 2);
        }
        else
        {
            imm64 = replicate_c((imm8 << 16) | ones(16), 32, 2);
        }
    }
    else if (cmode_test == 7)
    {
        if (bit_c(cmode, 0) == 0 && op == 0)
        {
            imm64 = replicate_c(imm8, 8, 8);
        }
        else if (bit_c(cmode, 0) == 0 && op == 1)
        {
            loop (8) i
            {
                int part = (0 - ((imm8 >> i) & 1)) & UINT8_MAX;

                imm64 = imm64 | (part << (i * 8));
            }
        }
        else if (bit_c(cmode, 0) == 1 && op == 0)
        {
            int p0 = bit_c(imm8, 7);                    //1
            int p1 = (~(bit_c(imm8, 6))) & 1;           //1
            int p2 = replicate_c(bit_c(imm8, 6),1,5);   //5
            int p3 = bits_c(imm8, 5, 0);                //6
            int p4 = 0;                                 //19
            
            int working = p4 | (p3 << 19) | (p2 << (19 + 6)) | (p1 << (19 + 6 + 5)) | (p0 << (19 + 6 + 5 + 1));

            imm64 = replicate_c(working, 32, 2);
        }
        else if (bit_c(cmode, 0) == 1 && op == 1)
        {
            int p0 = bit_c(imm8, 7);                    //1
            int p1 = (~(bit_c(imm8, 6))) & 1;           //1
            int p2 = replicate_c(bit_c(imm8, 6),1,8);   //8
            int p3 = bits_c(imm8, 5, 0);                //6
            int p4 = 0;                                 //48

            imm64 = p4 | (p3 << 48) | (p2 << (48 + 6)) | (p1 << (48 + 6 + 8)) | (p0 << (48 + 6 + 8 + 1));
        }
        else
        {
            undefined();
        }
    }
    else
    {
        undefined();
    }

    return imm64;
}

void VPart(int n, int part, int width, o64 value)
{
    if (part == 0)
    {
        V(n, value);
    }
    else
    {
        o128 src = V(n);
        
        elm src 1 64 value;
        
        V(n, src);
    }
}

/*
    Advanced SIMD copy
*/
fl_instruction 32 dup_general (0 Q_1 001110000 imm5_5 000011 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));

    int esize = 8 << size;
    int datasize = 64 << Q;

    o64 element = X(Rn);
    int elements = datasize / esize;

    o128 result = vector_zero;

    loop (elements) e
    {
        elm result e esize element;
    }

    V(Rd, result);
}

fl_instruction 32 dup_element_scalar (01011110000 imm5_5 000001 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));
    int index = bits_c(imm5, 4, size + 1);
    int idxdsize = 64 << bit_c(imm5, 4);
    int esize = 8 << size;
    int datasize = esize;
    int elements = 1;

    dup_element(index, esize, elements, Rn, Rd);
}

fl_instruction 32 dup_element_vector (0 Q_1 001110000 imm5_5 000001 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));
    int index = bits_c(imm5, 4, size + 1);
    int idxdsize = 64 << bit_c(imm5, 4);
    int esize = 8 << size;
    int datasize = 64 << Q;
    int elements = datasize / esize;

    dup_element(index, esize, elements, Rn, Rd);
}

/*
    SMOV
    UMOV
*/
fl_instruction 32 move_to_gp (0 Q_1 001110000 imm5_5 001 U_1 11 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));

    int esize = 8 << size;
    int datasize = 32 << Q;
    int index = bits_c(imm5, 4, size + 1);

    o128 operand = V(Rn);

    o_type S = switch esize { case 8 : o8, case 16 : o16, case 32 : o32, case 64 : o64 };
    o_type R = switch datasize { case 32 : o32, case 64 : o64 };

    R working_operand = elm operand index esize;

    if (!U)
    {
        working_operand = extend R (S)working_operand;
    }

    X(Rd, working_operand);
}

fl_instruction 32 ins_general (01001110000 imm5_5 000111 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));
    int index = bits_c(imm5, 4, size + 1);
    int esize = 8 << size;

    o64 element = X(Rn);
    o128 result = V(Rd);

    elm result index esize element;

    V(Rd, result);
}

fl_instruction 32 ins_element (01101110000 imm5_5 0 imm4_4 1 Rn_5 Rd_5)
{
    int size = lowest_bit_set_c(bits_c(imm5, 3, 0));
    int dst_index = bits_c(imm5, 4, size + 1);
    int src_index = bits_c(imm4, 3, size);
    int esize = 8 << size;

    o128 operand = V(Rn);
    o128 result = V(Rd);

    elm result dst_index esize (elm operand src_index esize);

    V(Rd, result);
}

/*
    Advanced SIMD modified immediate
*/
fl_instruction 32 movi_immediate (0 Q_1 op_1 0111100000 immhi_3 cmode_4 01 immlo_5 Rd_5)
{
    int d = Rd;

    int imm8 = (immhi << 5) | immlo;

    int cmode_helper = (cmode << 1) | op;
    int mode = 0;

    //ImmediateOp_ORR
    if (((cmode_helper & 19) == 2) || ((cmode_helper & 27) == 18))
    {
        mode = 0;
    }
    //ImmediateOp_BIC
    else if (((cmode_helper & 19) == 3) || ((cmode_helper & 27) == 19))
    {
        mode = 1;
    }
    //ImmediateOp_MVNI
    else if (((cmode_helper & 19) == 1) || ((cmode_helper & 27) == 17) || ((cmode_helper & 29) == 25))
    {
        mode = 2;
    }
    //ImmediateOp_MOVI
    else if (((cmode_helper & 19) == 0) || ((cmode_helper & 27) == 16) || ((cmode_helper & 29) == 24) || ((cmode_helper & 30) == 28) || ((cmode_helper & 31) == 30))
    {
        mode = 3;
    }
    //UNDEFINED
    else if (cmode_helper == 31)
    {
        if (Q == 0)
        {
            undefined();
        }

        mode = 3;
    }
    else
    {
        undefined();
    }

    o64 imm64 = expand_imm(op, cmode, imm8);
    o128 imm = imm64;

    if (Q)
    {
        elm imm 1 64 imm64;
    }

    o128 operand = vector_zero;
    o128 result = vector_zero;

    if (mode == 3)
    {
        result = imm;
    }
    else if (mode == 2)
    {
        loop (Q + 1) e
        {
            elm result e 64 ~(elm imm e 64);
        }
    }
    else if (mode == 0)
    {
        operand = V(Rd);

        loop (Q + 1) e
        {
            elm result e 64 ((elm operand e 64) | (elm imm e 64));
        }
    }
    else if (mode == 1)
    {
        operand = V(Rd);

        loop (Q + 1) e
        {
            elm result e 64 ((elm operand e 64) & ~(elm imm e 64));
        }
    }
    else
    {
        undefined();
    }

    V(Rd, result);
}

fl_instruction 32 fmov_general(sf_1 0011110 ftype_2 10 rmode_1 11 opcode_1 000000 Rn_5 Rd_5)
{
    int intsize = 32 << sf;
    int fltsize = get_flt_size(ftype);

    if (intsize != fltsize)
    {
        undefined();
    }

    int size = intsize;

    int part = rmode;
    int int_to_float = opcode;

    if (int_to_float)
    {
        o64 src = X(Rn);

        o_type O = switch size { case 32 : o32, case 64 : o64 };

        VPart(Rd, part, size, (O)src);
    }
    else
    {
        o128 v = V(Rn);

        o64 src = elm v part size;

        X(Rd, src);
    } 
}

void convert_to_float(int sf, int ftype,int U, int Rn, int Rd, int from_vector)
{
    int intsize = 32 << sf;
    int fltsize = get_flt_size(ftype);

    o_type I = switch intsize { case 32 : o32, case 64 : o64 };
    o_type F = switch fltsize { case 16 : o16, case 32 : o32, case 64 : o64 };

    F result;
    I operand;

    if (from_vector)
    {
        operand = V(Rn);
    }
    else
    {
        operand = X(Rn);
    }

    if (U)
    {
        result = to_float F operand;
    }
    else
    {
        result = to_float signed F operand;
    }

    V(Rd, result);
}

fl_instruction 32 convert_to_float_gp       (sf_1 0011110 ftype_2 10001 U_1 000000 Rn_5 Rd_5)
{
    convert_to_float(sf, ftype, U, Rn, Rd, false);
}

fl_instruction 32 convert_to_float_vector   (01 U_1 111100 sz_1 100001110110 Rn_5 Rd_5)
{
    convert_to_float(sz, sz, U, Rn, Rd, true);
}

fl_instruction 32 floating_point_scalar(00011110 ftype_2 1 Rm_5 opcode_4 10 Rn_5 Rd_5)
{
    int fltsize = get_flt_size(ftype);

    o64 operand1 = V(Rn);
    o64 operand2 = V(Rm);
    o64 result;

    o64 fpcr_state = _sys(external fpcr);

    if (opcode == 0)
    {
        result = FPMul(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 1)
    {
        result = FPDiv(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 2)
    {
        result = FPAdd(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 3)
    {   
        result = FPSub(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 4)
    {
        result = FPMax(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 5)
    {
        result = FPMin(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 6)
    {
        result = FPMaxNum(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 7)
    {
        result = FPMinNum(operand1, operand2, fpcr_state, fltsize);
    }
    else if (opcode == 8)
    {
        result = FPMul(operand1, operand2, fpcr_state, fltsize);

        result = FPNeg(result, fpcr_state, fltsize);
    }
    else
    {
        undefined_with(opcode);
    }

    o128 vector = vector_zero;

    elm vector 0 fltsize result;

    V(Rd, vector);
}

fl_instruction 32 conversion_between_floating_point_and_fixed_point(sf_1 0 S_1 11110 ftype_2 0 rmode_2 opcode_3 scale_6 Rn_5 Rd_5)
{
    int intsize = 32 << sf;
    int fltsize = get_flt_size(ftype);
    int fracbits = 64 - scale;

    o64 result;

    //int -> float
    if (rmode == 0)
    {
        o64 source = X(Rn);

        result = FixedToFP(source, fracbits, opcode == 3, fltsize, intsize);

        V(Rd, result);
    }
    //float -> int
    else if (rmode == 3)
    {
        o64 source = V(Rn);

        result = FPToFixed(source, fracbits, opcode == 1, external FPRounding_ZERO, intsize, fltsize);

        X(Rd, result);
    }
    else
    {
        undefined_with(0);
    }
}

fl_instruction 32 advanced_simd_three_same(0 Q_1 U_1 01110 size_2 1 Rm_5 opcode_5 1 Rn_5 Rd_5)
{
    o128 operand1 = V(Rn);
    o128 operand2 = V(Rm);
    o128 result = vector_zero;

    int esize = 8 << size;
    int datasize = 64 << Q;
    int elements = datasize / esize;

    o_type O = switch esize { case 8 : o8, case 16 : o16, case 32 : o32, case 64 : o64 };

    loop (elements) e
    {
        o64 element1 = elm operand1 e esize;
        o64 element2 = elm operand2 e esize;

        /*
            SHADD
            UHADD
        */
        if (opcode == 0)
        {
            if (!U)
            {
                element1 = extend o64 (O)element1;
                element2 = extend o64 (O)element2;
            }
            
            elm result e esize (element1 + element2) >> 1;
        }
        /*
            SRHADD
            URHADD
        */
        else if (opcode == 2)
        {
            if (!U)
            {
                element1 = extend o64 (O)element1;
                element2 = extend o64 (O)element2;
            }
            
            elm result e esize (element1 + element2 + 1) >> 1;
        }
        /*
            SHSUB
            UHSUB
        */
        else if (opcode == 4)
        {
            if (!U)
            {
                element1 = extend o64 (O)element1;
                element2 = extend o64 (O)element2;
            }
            
            elm result e esize (element1 - element2) >> 1;
        }
        /*
            CMGT
            CMHI
        */
        else if (opcode == 6)
        {
            O valid;

            if (U)
            {
                valid = ((O)element1) > ((O)element2);
            }
            else
            {
                valid = ((O)element1) cgt ((O)element2);
            }

            elm result e esize (0 - valid);
        }
        /*
            CMGE
            CMHS
        */
        else if (opcode == 7)
        {
            O valid;

            if (U)
            {
                valid = ((O)element1) >= ((O)element2);
            }
            else
            {
                valid = ((O)element1) cgte ((O)element2);
            }

            elm result e esize (0 - valid);
        }
        /*
            SSHL
            USHL
        */
        else if (opcode == 8 && size == 2)
        {
            O element = element1;
            O shift = extend O (o8)element2;

            element = vector_shift<O>(element, shift, esize, U);

            elm result e esize element;
        }
        /*
            SMAX
            UMAX
        */
        else if (opcode == 12)
        {
            O working = 0;

            if (U)
            {
                if (element1 > element2)
                {
                    set working element1;
                }
                else
                {
                    set working element2;
                }
            }
            else
            {   
                if (((O)element1) cgt ((O)element2))
                {
                    set working element1;
                }
                else
                {
                    set working element2;
                }
            }

            elm result e esize working;
        }
        /*
            UMIN
            SMIN
        */
        else if (opcode == 13)
        {
            O working = 0;

            if (U)
            {
                if (element1 < element2)
                {
                    set working element1;
                }
                else
                {
                    set working element2;
                }
            }
            else
            {   
                if (((O)element1) clt ((O)element2))
                {
                    set working element1;
                }
                else
                {
                    set working element2;
                }
            }

            elm result e esize working;
        }
        /*
            ORR
            ORN
        */
        else if (opcode == 3 && ((size >> 1) == 1) && U == 0)
        {
            if (size & 1)
            {
                element2 = ~element2;
            }

            elm result e esize (element1 | element2);
        }
        /*
            AND
            BIC
        */
        else if (opcode == 3 && ((size >> 1) == 0) && U == 0)
        {
            if (size & 1)
            {
                element2 = ~element2;
            }

            elm result e esize (element1 & element2);
        }
        /*
            EOR
        */
        else if (opcode == 3 && size == 0 && U == 1)
        {
            elm result e esize (element1 ^ element2);
        }
        else
        {
            undefined_with(0);
        }
    }

    V(Rd, result);
}

/*
    FCSEL
*/
fl_instruction 32 floating_point_conditional_select(00011110 ftype_2 1 Rm_5 cond_4 11 Rn_5 Rd_5)
{
    int fltsize = get_flt_size(ftype);

    o128 operand1 = V(Rn);
    o128 operand2 = V(Rm);

    o_type O = switch fltsize { case 32 : o32, case 64 : o64 };

    O result = 0;

    if (condition_holds(cond))
    {
        set result operand1;
    }
    else
    {
        set result operand2;
    }

    V(Rd, result);
}

/*
    FMOV imm
*/
fl_instruction 32 fmov_scalar_immediate(00011110 ftype_2 1 imm8_8 10000000 Rd_5)
{
    int fltsize = get_flt_size(ftype);

    o64 imm = vfp_expand_imm(imm8, fltsize);

    V(Rd, imm);
}

/*
    FCVT
*/
fl_instruction 32 fcvt(00011110 ftype_2 10001 opc_2 10000 Rn_5 Rd_5)
{
    int srcsize = get_flt_size(ftype);
    int dstsize = get_flt_size(opc);

    o64 operand = V(Rn);
    
    V(Rd,FPConvert(operand, dstsize, srcsize));
}

/*
    FABS
    FPNEG
    FPSqrt
*/
fl_instruction 32 floating_point_data_processing_one_source(M_1 0 S_1 11110 ftype_2 1 opcode_6 10000 Rn_5 Rd_5)
{
    int fltsize = get_flt_size(ftype);

    o64 operand = V(Rn);
    o64 result = 0;

    o64 fpcr_state = _sys(external fpcr);

    if (opcode == 1)
    {
        result = FPAbs(operand, fpcr_state, fltsize);
    }
    else if (opcode == 2)
    {
        result = FPNeg(operand, fpcr_state, fltsize);
    }
    else if (opcode == 3)
    {
        result = FPSqrt(operand, fpcr_state, fltsize);
    }
    else
    {
        undefined_with(0);
    }

    o128 vector = vector_zero;

    elm vector 0 fltsize result;

    V(Rd, vector);
}

/*
    FCMP
*/
fl_instruction 32 fcmp(00011110 ftype_2 1 Rm_5 001000 Rn_5 0 opc_1 000)
{
    int datasize = get_flt_size(ftype);
    int cmp_with_zero = opc == 1;

    o64 operand1 = V(Rn);
    o64 operand2;

    o64 fpcr_state = _sys(external fpcr);

    if (cmp_with_zero)
    {
        operand2 = 0;
    }
    else
    {
        operand2 = V(Rm);
    }

    o64 nzcv = FPCompare(operand1, operand2, fpcr_state, datasize);

    _sys(external nzcv_n, (nzcv >> 3) & 1);
    _sys(external nzcv_z, (nzcv >> 2) & 1);
    _sys(external nzcv_c, (nzcv >> 1) & 1);
    _sys(external nzcv_v, (nzcv >> 0) & 1);
}

/*
    FCCMP
*/
fl_instruction 32 fccmp(00011110 ftype_2 1 Rm_5 cond_4 01 Rn_5 0 nzcv_4)
{
    int datasize = get_flt_size(ftype);

    o64 operand1 = V(Rn);
    o64 operand2 = V(Rm);

    o64 fpcr_state = _sys(external fpcr);

    if (condition_holds(cond))
    {
        o64 success_nzcv = FPCompare(operand1, operand2, fpcr_state, datasize);

        _sys(external nzcv_n, (success_nzcv >> 3) & 1);
        _sys(external nzcv_z, (success_nzcv >> 2) & 1);
        _sys(external nzcv_c, (success_nzcv >> 1) & 1);
        _sys(external nzcv_v, (success_nzcv >> 0) & 1);
    }
    else
    {
        _sys(external nzcv_n, (nzcv >> 3) & 1);
        _sys(external nzcv_z, (nzcv >> 2) & 1);
        _sys(external nzcv_c, (nzcv >> 1) & 1);
        _sys(external nzcv_v, (nzcv >> 0) & 1);
    }
}

/*
    FCVTZS
    FCVTZU
*/
fl_instruction 32 fcvtz_scalar_integer(sf_1 0011110 ftype_2 11100 U_1 000000 Rn_5 Rd_5)
{
    convert_to_int(sf, ftype, Rd, Rn, external FPRounding_ZERO, U, 0);
}

/*
    FCVTNS
    FCVTNU
*/
fl_instruction 32 fcvtn_scalar_integer(sf_1 0011110 ftype_2 10000 U_1 000000 Rn_5 Rd_5)
{
    convert_to_int(sf, ftype, Rd, Rn, external FPRounding_TIEEVEN, U, 0);
}

/*
    FCVTAS
    FCVTAU
*/
fl_instruction 32 fcvta_scalar_integer(sf_1 0011110 ftype_2 10010 U_1 000000 Rn_5 Rd_5)
{
    convert_to_int(sf, ftype, Rd, Rn, external FPRounding_TIEAWAY, U, 0);
}

/*
    FCVTMS
    FCVTMU
*/
fl_instruction 32 fcvtm_scalar_integer(sf_1 0011110 ftype_2 11000 U_1 000000 Rn_5 Rd_5)
{
    convert_to_int(sf, ftype, Rd, Rn, external FPRounding_NEGINF, U, 0);
}

/*
    FCVTPS
    FCVTPU
*/
fl_instruction 32 fcvtp_scalar_integer(sf_1 0011110 ftype_2 10100 U_1 000000 Rn_5 Rd_5)
{
    convert_to_int(sf, ftype, Rd, Rn, external FPRounding_POSINF, U, 0);
}

/*
    UADDLV
    SADDLV
*/
fl_instruction 32 addlv(0 Q_1 U_1 01110 size_2 110000001110 Rn_5 Rd_5)
{
    int esize = 8 << size;
    int datasize = 64 << Q;
    int elements = datasize / esize;

    int is_unsigned = U;

    o128 source = V(Rn);
    o128 operand = V(Rn);
    
    o64 sum = 0;

    loop (elements) e
    {
        o64 working = (elm operand e esize);

        if (!is_unsigned)
        {
            o_type O = switch esize { case 8 : o8, case 16 : o16, case 32 : o32, case 64 : o64 };

            working = extend o64 (O)working;
        }

        sum = sum + working;
    }

    o128 final = vector_zero;

    elm final 0 (2 * esize) sum;

    V(Rd, final);
}

/*
    CNT
*/
fl_instruction 32 cnt(0 Q_1 001110 size_2 100000010110 Rn_5 Rd_5)
{
    int esize = 8;
    int datasize = 64 << Q;
    int elements = datasize / 8;

    o128 source = V(Rn);
    o128 result = vector_zero;

    loop (elements) e
    {
        o8 working = elm source e esize;
        o8 count = 0;

        loop (esize) b
        {
            o8 bit = (working >> b) & 1;

            if (bit)
            {
                set count (count + 1);
            }
        }

        elm result e esize count;
    } 

    V(Rd, result);
}